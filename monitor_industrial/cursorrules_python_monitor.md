# Cursor Rules - Monitor Industrial Python (Raspberry Pi)

## üçì INFORMACI√ìN DEL PROYECTO

**Nombre**: monitor-industrial-python
**Descripci√≥n**: Monitor industrial para Raspberry Pi que se comunica con SISPRO (Next.js) y Raspberry Pi Pico
**Tipo**: Aplicaci√≥n Python standalone
**Lenguaje Principal**: Python 3.9+
**Hardware**: Raspberry Pi + Raspberry Pi Pico
**Comunicaci√≥n**: RS485 (Pi ‚Üî Pico), HTTP/WebSocket (Pi ‚Üî SISPRO)

## üèóÔ∏è ARQUITECTURA DEL SISTEMA

### Componentes Principales

```
Raspberry Pi (Python)
‚îú‚îÄ‚îÄ MonitorRS485 (comunicaci√≥n con Pico)
‚îú‚îÄ‚îÄ SISPROConnector (comunicaci√≥n con Next.js)
‚îú‚îÄ‚îÄ BarcodeValidator (validaci√≥n UPC)
‚îú‚îÄ‚îÄ CacheManager (Redis + SQLite)
‚îú‚îÄ‚îÄ WebSocketServer (tiempo real)
‚îî‚îÄ‚îÄ EstadoManager (gesti√≥n de estados)

Raspberry Pi Pico
‚îú‚îÄ‚îÄ Sensor RS485
‚îú‚îÄ‚îÄ Env√≠o de conteos
‚îî‚îÄ‚îÄ Recepci√≥n de comandos
```

## üîå COMUNICACI√ìN CON SISPRO (Next.js)

### ‚úÖ **TODAS LAS APIs YA EXISTEN** - No crear APIs adicionales

#### 0. **Conexi√≥n con SISPRO** ‚úÖ (SIN AUTENTICACI√ìN JWT)

```python
# Configuraci√≥n de conexi√≥n (LOGIN LOCAL - Sin autenticaci√≥n JWT)
SISPRO_CONFIG = {
    "base_url": "http://100.24.193.207:3000",  # IP alternativa: sisproone.net
    "empresa_id": 1  # Siempre usar empresa-id 1
}

# Verificar conectividad con SISPRO
async def verificar_conectividad():
    """Verificar que SISPRO est√© disponible"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                f"{SISPRO_CONFIG['base_url']}/api/estacionesTrabajo",
                headers={'empresa-id': str(SISPRO_CONFIG["empresa_id"])},
                timeout=10
            ) as response:
                return response.status == 200
    except Exception as e:
        print(f"‚ùå Error de conectividad: {e}")
        return False

# Headers est√°ndar para todas las APIs (SIN TOKEN)
def get_headers():
    return {
        'empresa-id': str(SISPRO_CONFIG["empresa_id"]),
        'Content-Type': 'application/json'
    }

# Ejemplo de uso
if await verificar_conectividad():
    print(f"‚úÖ SISPRO conectado - Empresa ID: {SISPRO_CONFIG['empresa_id']}")
else:
    print(f"‚ùå Error de conectividad con SISPRO")
```

#### 1. **Obtener Estaciones de Trabajo** ‚úÖ

```python
# GET /api/estacionesTrabajo
# Headers: { "empresa-id": "1" }  # Siempre usar empresa-id 1
# Respuesta: {
#   "success": true,
#   "data": [
#     {
#       "id": 1,
#       "nombre": "Estaci√≥n 001",
#       "descripcion": "Descripci√≥n",
#       "estado": "ASIGNADA",
#       "coordinadorSupervisor": "Juan",
#       "cuadrante": "Cuadrante A"
#     }
#   ]
# }
```

#### 2. **Obtener √ìrdenes Asignadas** ‚úÖ

```python
# GET /api/ordenesDeFabricacion/listarAsignadas?estacionTrabajoId=1
# Headers: { "empresa-id": "1" }  # Siempre usar empresa-id 1
# Respuesta: {
#   "success": true,
#   "data": [
#     {
#       "id": 1,
#       "ordenFabricacion": "OF-001",
#       "pt": "PT-001",
#       "cantidadFabricar": 1000,
#       "cantidadPendiente": 500,
#       "avance": 0.5,
#       "ptDescripcion": "Producto A",
#       "ptPresentacion": "Caja x 10",
#       "ptUPC": "1234567890",
#       "estacionNombre": "Estaci√≥n 001",
#       "estacionCoordinador": "Juan",
#       "estacionCuadrante": "Cuadrante A",
#       "prioridad": "NORMAL",
#       "isClosed": false
#     }
#   ]
# }
```

#### 3. **Validar UPC** ‚úÖ

```python
# POST /api/lecturaUPC/registrar
# Headers: { "empresa-id": "1" }  # Siempre usar empresa-id 1
# Body: {
#   "ordenFabricacion": "OF-001",
#   "upc": "1234567890",
#   "estacionId": 1,
#   "usuarioId": 1
# }
# Respuesta: { "success": true, "message": "Lectura registrada correctamente" }
```

#### 4. **Sincronizar Lecturas del Pico** ‚úÖ

```python
# POST /api/lecturaUPC/registrar (usar para sincronizar lecturas del Pico)
# Headers: { "empresa-id": "1" }
# Body: {
#   "ordenFabricacion": "OF-001",
#   "upc": "RS485_BATCH",  # Identificador para lecturas del Pico
#   "estacionId": 1,
#   "usuarioId": 1
# }
# Respuesta: { "success": true, "message": "Lectura registrada correctamente" }
```

#### 5. **Consultar Avance de Orden** ‚úÖ

```python
# GET /api/ordenesDeFabricacion/avance?ordenFabricacion=OF-001
# Headers: { "empresa-id": "1" }  # Siempre usar empresa-id 1
# Respuesta: {
#   "success": true,
#   "data": {
#     "cantidadPendiente": 450,
#     "avance": 0.55
#   }
# }
```

#### 6. **Consultar Detalles Completos de Orden** ‚úÖ

```python
# GET /api/ordenesDeFabricacion/estatus?orden=OF-001
# Headers: { "empresa-id": "1" }
# Respuesta: {
#   "success": true,
#   "data": {
#     "ordenFabricacion": "OF-001",
#     "estatus": "EN_PROCESO",
#     "fechaInicio": "2024-12-01",
#     "fechaFin": "2024-12-15",
#     "cliente": "Cliente ABC",
#     "razonSocial": "Empresa ABC S.A.",
#     "articuloPT": "PT-001",
#     "descripcionPT": "Producto Terminado",
#     "cantidadPlanificada": 1000,
#     "caja": "Caja x 10",
#     "partidas": [
#       {
#         "articuloMP": "MP-001",
#         "descripcionMP": "Materia Prima A",
#         "cantidad": 500
#       }
#     ]
#   }
# }
```

#### 7. **Consultar Cajas Registradas** ‚úÖ

```python
# GET /api/lecturaUPC/cajas?ordenFabricacion=OF-001
# Headers: { "empresa-id": "1" }
# Respuesta: {
#   "success": true,
#   "total": 125  # N√∫mero de cajas registradas
# }
```

#### 8. **Registrar Caja (UPC Especial)** ‚úÖ

```python
# POST /api/lecturaUPC/registrarCaja
# Headers: { "empresa-id": "1" }
# Body: {
#   "ordenFabricacion": "OF-001",
#   "upc": "1234567890",
#   "estacionId": 1,
#   "usuarioId": 1
# }
# Respuesta: { "success": true, "message": "Caja registrada correctamente" }
```

#### 9. **Registrar Lote de Lecturas** ‚úÖ

```python
# POST /api/lecturaUPC/registrarLote
# Headers: { "empresa-id": "1" }
# Body: {
#   "lecturas": [
#     {
#       "ordenFabricacion": "OF-001",
#       "upc": "1234567890",
#       "estacionId": 1,
#       "usuarioId": 1,
#       "fechaLectura": "2024-12-01T10:30:00.000Z"
#     }
#   ]
# }
# Respuesta: { "success": true, "message": "Lote registrado correctamente" }
```

#### 10. **Obtener Imagen del Art√≠culo** ‚úÖ

```python
# GET /api/articulos/imagen?articulo=PT-001
# Headers: { "empresa-id": "1" }
# Respuesta: {
#   "success": true,
#   "data": {
#     "url": "https://sisproone.net/images/articulos/PT-001.jpg"
#   }
# }
```

## üéØ FLUJO DE TRABAJO

### 1. **Inicializaci√≥n**

```python
# 1. Cargar configuraci√≥n guardada (estaci√≥n, empresa_id=1)
# 2. Autenticar con SISPRO usando credenciales MONITORPI
# 3. Conectar a RS485
# 4. Iniciar WebSocket server
```

### 2. **Selecci√≥n de Estaci√≥n**

```python
# 1. Consultar estaciones disponibles desde SISPRO
# 2. Mostrar lista de estaciones
# 3. Seleccionar estaci√≥n (se guarda globalmente)
# 4. Consultar √≥rdenes asignadas para la estaci√≥n
```

### 3. **Selecci√≥n de Orden**

```python
# 1. Mostrar √≥rdenes disponibles
# 2. Seleccionar orden de fabricaci√≥n
# 3. Consultar detalles completos de la orden (/api/ordenesDeFabricacion/estatus)
# 4. Obtener imagen del art√≠culo (/api/articulos/imagen)
# 5. Consultar cajas ya registradas (/api/lecturaUPC/cajas)
# 6. Cambiar estado a "ESPERANDO_UPC"
# 7. Activar escucha de c√≥digo de barras
```

### 4. **Validaci√≥n UPC**

```python
# 1. Escanear c√≥digo de barras
# 2. Validar contra ptUPC de la orden
# 3. UPC especial "1234567890128" = Cierre de caja
# 4. Si v√°lido: agregar a lote local y cambiar estado a "PRODUCIENDO"
# 5. Si inv√°lido: mostrar error y reintentar
# 6. Consultar progreso actual (/api/ordenesDeFabricacion/avance)
```

### 5. **Producci√≥n Local**

```python
# 1. Activar escucha RS485 del Pico
# 2. Recibir conteos en tiempo real
# 3. Almacenar en cache local (Redis + SQLite)
# 4. Mostrar progreso en pantalla
# 5. Manejar estados localmente
```

### 6. **Sincronizaci√≥n**

```python
# 1. Acumular lecturas del Pico en lotes locales (m√°ximo 50 lecturas)
# 2. Enviar lotes usando /api/lecturaUPC/registrarLote
# 3. Registrar cajas especiales usando /api/lecturaUPC/registrarCaja
# 4. Consultar progreso actual (/api/ordenesDeFabricacion/avance)
# 5. Verificar estatus de orden (/api/ordenesDeFabricacion/estatus)
# 6. Limpiar cache local
# 7. Repetir cada 5 minutos o cuando se complete un lote
```

## üìä ESTRUCTURA DE DATOS

### Estaci√≥n

```python
class Estacion:
    id: int
    nombre: str
    descripcion: str
    estado: str  # ASIGNADA, INACTIVA
    coordinador_supervisor: str
    cuadrante: str
```

### Orden de Fabricaci√≥n

```python
class OrdenFabricacion:
    id: int
    orden_fabricacion: str
    pt: str
    cantidad_fabricar: int
    cantidad_pendiente: int
    avance: float
    pt_descripcion: str
    pt_presentacion: str
    pt_upc: str
    estacion_nombre: str
    estacion_coordinador: str
    estacion_cuadrante: str
    prioridad: str  # NORMAL, ALTA, URGENTE
    is_closed: bool
```

### Detalles Completos de Orden

```python
class DetallesOrden:
    orden_fabricacion: str
    estatus: str  # EN_PROCESO, CANCELADA, COMPLETADA
    fecha_inicio: str
    fecha_fin: str
    cliente: str
    razon_social: str
    articulo_pt: str
    descripcion_pt: str
    cantidad_planificada: int
    caja: str
    partidas: List[MateriaPrima]

class MateriaPrima:
    articulo_mp: str
    descripcion_mp: str
    cantidad: int
```

### Lectura de Producci√≥n

```python
class LecturaProduccion:
    orden_fabricacion: str
    upc: str
    estacion_id: int
    usuario_id: int
    fecha_lectura: str  # ISO timestamp
    fuente: str  # RS485, BARCODE
    validada: bool

class LoteLecturas:
    lecturas: List[LecturaProduccion]
    timestamp_envio: datetime
    estado: str  # PENDIENTE, ENVIADO, ERROR
    intentos: int

class CajaRegistrada:
    orden_fabricacion: str
    upc: str
    estacion_id: int
    usuario_id: int
    fecha_registro: str
```

## üîß IMPLEMENTACI√ìN T√âCNICA

### Configuraci√≥n

```python
# config.py
SISPRO_CONFIG = {
    "base_url": "http://100.24.193.207:3000",  # IP alternativa: sisproone.net
    "username": "MONITORPI",
    "password": "56fg453drJ",
    "empresa_id": 1  # Siempre usar empresa-id 1
}

# Configuraci√≥n de hardware
RS485_PORT = "/dev/ttyUSB0"
RS485_BAUDRATE = 9600

# Configuraci√≥n de cache
REDIS_HOST = "localhost"
REDIS_PORT = 6379

# Configuraci√≥n de servicios
WEBSOCKET_PORT = 8765

# Configuraci√≥n de sincronizaci√≥n
SYNC_INTERVAL = 300  # 5 minutos en segundos
MAX_RETRIES = 3
TIMEOUT = 30  # segundos

# Configuraci√≥n de lotes
MAX_BATCH_SIZE = 50  # M√°ximo de lecturas por lote
BATCH_TIMEOUT = 60  # Enviar lote despu√©s de X segundos sin actividad
UPC_CIERRE_CAJA = "1234567890128"  # UPC especial para cierre de caja
```

### Estados del Monitor

```python
class EstadoMonitor:
    INACTIVO = "INACTIVO"
    CONSULTANDO = "CONSULTANDO"
    ESPERANDO_UPC = "ESPERANDO_UPC"
    PRODUCIENDO = "PRODUCIENDO"
    PAUSADO = "PAUSADO"
    ERROR = "ERROR"
```

### Cache Manager

```python
class CacheManager:
    def __init__(self):
        self.redis = redis.Redis(host='localhost', port=6379, db=0)
        self.db = sqlite3.connect('monitor_cache.db')

    def guardar_lectura(self, estacion_id: str, datos: dict):
        # Guardar en SQLite (persistencia)
        # Guardar en Redis (acceso r√°pido)
        pass

    def obtener_estado(self, estacion_id: str = None):
        # Obtener desde Redis
        pass

    def obtener_lecturas_pendientes(self, estacion_id: str):
        # Obtener lecturas no enviadas
        pass
```

### Lote Manager

```python
class LoteManager:
    def __init__(self):
        self.lecturas_pendientes = []
        self.ultimo_timestamp = None
        self.max_batch_size = MAX_BATCH_SIZE
        self.batch_timeout = BATCH_TIMEOUT

    def agregar_lectura(self, lectura: LecturaProduccion):
        """Agregar lectura al lote actual"""
        self.lecturas_pendientes.append(lectura)
        self.ultimo_timestamp = datetime.now()

        # Enviar si alcanzamos el tama√±o m√°ximo
        if len(self.lecturas_pendientes) >= self.max_batch_size:
            return self.enviar_lote()

    def verificar_timeout(self):
        """Verificar si debemos enviar por timeout"""
        if (self.ultimo_timestamp and
            datetime.now() - self.ultimo_timestamp > timedelta(seconds=self.batch_timeout)):
            return self.enviar_lote()

    def enviar_lote(self):
        """Enviar lote actual a SISPRO"""
        if not self.lecturas_pendientes:
            return

        lote = self.lecturas_pendientes.copy()
        self.lecturas_pendientes.clear()
        return lote

    def obtener_cantidad_pendiente(self):
        """Obtener cantidad de lecturas pendientes"""
        return len(self.lecturas_pendientes)
```

### Clase Principal del Monitor

```python
class MonitorIndustrial:
    def __init__(self):
        self.config = SISPRO_CONFIG
        self.empresa_id = SISPRO_CONFIG["empresa_id"]
        self.sispro = SISPROConnector()
        self.rs485 = MonitorRS485()
        self.barcode = BarcodeValidator()
        self.cache = CacheManager()
        self.lote_manager = LoteManager()
        self.websocket = WebSocketServer()
        self.estado = EstadoManager()

    async def inicializar(self):
        """Inicializar el monitor (sin autenticaci√≥n JWT)"""
        try:
            # 1. Verificar conectividad con SISPRO
            print("üîê Verificando conectividad con SISPRO...")
            if not await self.sispro.verificar_conectividad():
                print("‚ùå Error de conectividad con SISPRO")
                return False
            print(f"‚úÖ SISPRO conectado - Empresa ID: {self.empresa_id}")

            # 2. Conectar RS485
            print("üîå Conectando a RS485...")
            if not self.rs485.conectar():
                print("‚ùå Error conectando RS485")
                return False
            print("‚úÖ RS485 conectado")

            # 3. Iniciar servicios
            print("üöÄ Iniciando servicios...")
            await self.websocket.iniciar()
            await self.cache.inicializar()
            print("‚úÖ Servicios iniciados")

            return True

        except Exception as e:
            print(f"‚ùå Error en inicializaci√≥n: {e}")
            return False

    async def ejecutar(self):
        """Ejecutar el ciclo principal del monitor"""
        print("üè≠ Monitor Industrial iniciado")

        while True:
            try:
                # Procesar ciclo principal
                await self.procesar_ciclo()
                await asyncio.sleep(0.1)

            except KeyboardInterrupt:
                print("\nüõë Deteniendo monitor...")
                break
            except Exception as e:
                print(f"‚ùå Error en ciclo principal: {e}")
                await asyncio.sleep(5)  # Esperar antes de reintentar

    async def procesar_ciclo(self):
        """Procesar un ciclo del monitor"""
        # L√≥gica del ciclo principal
        pass
```

## üöÄ COMANDOS RS485

### Comandos para Pico

```python
# Activar estaci√≥n
comando = f"{device_id}:ACTIVAR:{producto_id}"

# Pausar estaci√≥n
comando = f"{device_id}:PAUSAR:0"

# Resetear estaci√≥n
comando = f"{device_id}:RESET:0"

# Establecer meta
comando = f"{device_id}:META:{cantidad}"
```

### Respuestas del Pico

```python
# Formato: "DEVICE_ID:TAG:VALOR"
# Ejemplos:
# "EST001:CONT:1250"     # Contador actual
# "EST001:TOTAL:5000"    # Total acumulado
# "EST001:ESTADO:1"      # 1=Activo, 0=Inactivo
# "EST001:RESET:0"       # Reset confirmado
```

## üì± INTERFAZ DE USUARIO

### Men√∫ Principal

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üçì MONITOR INDUSTRIAL SISPRO       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìç Estaci√≥n: EST001                ‚îÇ
‚îÇ üîÑ Estado: PRODUCIENDO             ‚îÇ
‚îÇ üì¶ Orden: OF-001                   ‚îÇ
‚îÇ üî¢ Contador: 1,247 / 5,000        ‚îÇ
‚îÇ üìä Progreso: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë 24.9%     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Configurar estaci√≥n             ‚îÇ
‚îÇ 2. Consultar carga de trabajo      ‚îÇ
‚îÇ 3. Seleccionar orden               ‚îÇ
‚îÇ 4. Ver estado actual               ‚îÇ
‚îÇ 5. Salir                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Estados Visuales

- üî¥ **INACTIVO**: Monitor apagado
- üü° **CONSULTANDO**: Consultando SISPRO
- üü° **ESPERANDO_UPC**: Esperando c√≥digo de barras
- üü¢ **PRODUCIENDO**: Contando con Pico
- üü† **PAUSADO**: Producci√≥n pausada
- üî¥ **ERROR**: Error de comunicaci√≥n

## üîÑ SINCRONIZACI√ìN

### Sincronizaci√≥n con SISPRO

```python
# Cada 5 minutos
async def sincronizar_datos():
    datos = cache.obtener_estado()
    await sispro.enviar_lecturas(datos)
    await sispro.actualizar_estados(datos)
```

### Sincronizaci√≥n con Pico

```python
# Tiempo real
async def procesar_mensaje_rs485(mensaje):
    datos = parsear_mensaje(mensaje)
    cache.guardar_lectura(datos)
    await websocket.broadcast(datos)
```

## üõ†Ô∏è DEPENDENCIAS

### Python Packages

```txt
aiohttp>=3.8.0
asyncio
pyserial>=3.5
redis>=4.0.0
websockets>=10.0
sqlite3
datetime
json
```

### Hardware

- Raspberry Pi 4B+
- Raspberry Pi Pico
- M√≥dulo RS485
- Lector de c√≥digo de barras USB
- Pantalla t√°ctil (opcional)

## üìÅ ESTRUCTURA DE ARCHIVOS

```
monitor_industrial/
‚îú‚îÄ‚îÄ main.py                 # Punto de entrada
‚îú‚îÄ‚îÄ config.py              # Configuraci√≥n
‚îú‚îÄ‚îÄ monitor_rs485.py       # Comunicaci√≥n RS485
‚îú‚îÄ‚îÄ sispro_connector.py    # Comunicaci√≥n SISPRO
‚îú‚îÄ‚îÄ barcode_validator.py   # Validaci√≥n UPC
‚îú‚îÄ‚îÄ cache_manager.py       # Gesti√≥n de cache
‚îú‚îÄ‚îÄ websocket_server.py    # Servidor WebSocket
‚îú‚îÄ‚îÄ estado_manager.py      # Gesti√≥n de estados
‚îú‚îÄ‚îÄ interfaz.py           # Interfaz de usuario
‚îú‚îÄ‚îÄ requirements.txt      # Dependencias
‚îú‚îÄ‚îÄ monitor_cache.db      # Base de datos local
‚îî‚îÄ‚îÄ logs/                 # Archivos de log
```

### Script Principal (main.py)

```python
#!/usr/bin/env python3
"""
Monitor Industrial - Punto de entrada principal
"""

import asyncio
import sys
from monitor_industrial import MonitorIndustrial

async def main():
    """Funci√≥n principal del monitor"""
    print("üçì MONITOR INDUSTRIAL SISPRO")
    print("=" * 50)

    # Crear instancia del monitor
    monitor = MonitorIndustrial()

    # Inicializar el monitor
    if not await monitor.inicializar():
        print("‚ùå No se pudo inicializar el monitor")
        sys.exit(1)

    try:
        # Ejecutar el monitor
        await monitor.ejecutar()
    except KeyboardInterrupt:
        print("\nüõë Monitor detenido por el usuario")
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
```

## üîí SEGURIDAD

### Autenticaci√≥n

- **Credenciales espec√≠ficas**:
  - Usuario: `MONITORPI`
  - Password: `56fg453drJ`
  - URL: `http://100.24.193.207:3000` (alternativa: `sisproone.net`)
  - Empresa ID: `1` (fijo)
- **Token JWT** para SISPRO obtenido via middleware
- **Renovaci√≥n autom√°tica** de tokens cuando expire
- **Manejo seguro** de credenciales en variables de entorno

### Validaci√≥n

- Validaci√≥n de UPC contra orden asignada
- Verificaci√≥n de estaci√≥n autorizada
- Logs de todas las operaciones

## ‚ö° PERFORMANCE

### Optimizaciones

- Cache local para datos frecuentes
- Sincronizaci√≥n as√≠ncrona con SISPRO
- Procesamiento en tiempo real de RS485
- WebSocket para actualizaciones instant√°neas

### Monitoreo

- Logs de rendimiento
- M√©tricas de comunicaci√≥n
- Alertas de errores
- Estado de conexiones

## üß™ TESTING

### Tests Unitarios

- Validaci√≥n de UPC
- Comunicaci√≥n RS485
- Cache management
- Sincronizaci√≥n SISPRO

### Tests de Integraci√≥n

- Flujo completo de producci√≥n
- Comunicaci√≥n Pi ‚Üî Pico
- Comunicaci√≥n Pi ‚Üî SISPRO
- Recuperaci√≥n de errores

## üìã CHECKLIST DE IMPLEMENTACI√ìN

### Fase 1: Base

- [ ] Configuraci√≥n inicial
- [ ] Comunicaci√≥n RS485
- [ ] Cache local (SQLite + Redis)
- [ ] Interfaz b√°sica

### Fase 2: SISPRO (APIs ya existen)

- [ ] Autenticaci√≥n
- [ ] Consulta de estaciones
- [ ] Consulta de √≥rdenes
- [ ] Validaci√≥n UPC
- [ ] Sincronizaci√≥n de lecturas

### Fase 3: Producci√≥n

- [ ] Validaci√≥n UPC
- [ ] Estados de producci√≥n
- [ ] Sincronizaci√≥n
- [ ] WebSocket server

### Fase 4: Optimizaci√≥n

- [ ] Manejo de errores
- [ ] Recuperaci√≥n autom√°tica
- [ ] Logs y monitoreo
- [ ] Tests

## üö® CONSIDERACIONES IMPORTANTES

### Robustez

- Manejo de desconexiones de red
- Recuperaci√≥n autom√°tica de errores
- Persistencia de datos cr√≠ticos
- Logs detallados para debugging

### Escalabilidad

- Soporte para m√∫ltiples estaciones
- Configuraci√≥n flexible
- F√°cil mantenimiento
- Documentaci√≥n completa

### Mantenimiento

- Logs rotativos
- Monitoreo de salud
- Alertas autom√°ticas
- Actualizaciones remotas

## üöÄ **RESUMEN EJECUTIVO**

### ‚úÖ **TODAS LAS APIs YA EXISTEN**

- **No crear APIs adicionales** - Usar las existentes en SISPRO
- **Integraci√≥n completa** - Se conecta directamente con el sistema actual
- **M√°xima eficiencia** - Todo local + sincronizaci√≥n inteligente

### üéØ **ARQUITECTURA SIMPLIFICADA**

- **Raspberry Pi maneja TODO localmente** - Sin dependencias de red
- **Solo sincroniza al final** - Cada 5 minutos o cuando sea necesario
- **Cache inteligente** - Datos en memoria + disco
- **Recuperaci√≥n autom√°tica** - Reinicia solo si falla

### üìä **FLUJO DE TRABAJO**

1. **Inicializaci√≥n** ‚Üí Cargar config + autenticar SISPRO
2. **Selecci√≥n de Estaci√≥n** ‚Üí Consultar estaciones + guardar globalmente
3. **Selecci√≥n de Orden** ‚Üí Consultar √≥rdenes asignadas + mostrar men√∫
4. **Validaci√≥n UPC** ‚Üí Escanear c√≥digo + validar contra orden
5. **Producci√≥n Local** ‚Üí Activar RS485 + procesar conteos localmente
6. **Sincronizaci√≥n** ‚Üí Subir lecturas a SISPRO cada 5 minutos

### üéâ **RESULTADO FINAL**

**¬°El proyecto est√° 100% listo para implementar!**

- ‚úÖ **Sin APIs adicionales** - Usa las existentes
- ‚úÖ **Arquitectura simple** - Todo local + sincronizaci√≥n
- ‚úÖ **M√°xima eficiencia** - Tiempo real + confiabilidad
- ‚úÖ **F√°cil mantenimiento** - Un solo sistema de APIs

---

**Versi√≥n**: 1.1.0
**√öltima actualizaci√≥n**: Diciembre 2024
**Mantenido por**: Equipo de Desarrollo sisproone
